Practical Combinatorial Testing
________________________________________________________________
           Using Table 4, we can now calculate the total number of configurations:
3 ⋅ 3 ⋅ 4 ⋅ 3 ⋅ 5 ⋅ 4 ⋅ 4 ⋅ 5 ⋅ 4 = 172,800 configurations (i.e., a 33 4 45 2 system). Like many
applications, thorough testing will require some human intervention to run tests and verify results,
and a test suite will typically include many tests. If each test suite can be run in 15 minutes, it will
take roughly 24 staff-years to complete testing for an app. With salary and benefit costs for each
tester of $150,000, the cost of testing an app will be more than $3 million, making it virtually
impossible to return a profit for most apps. How can we provide effective testing for apps at a
reasonable cost?

        Using the covering array generator, we can produce tests that cover t-way
combinations of values. Table 5 shows the number of tests required at several levels of t.
For many applications, 2-way or 3-way testing may be appropriate, and either of these will
require less than 1% of the time required to cover all possible test configurations.

                                   t   # Tests    % of Exhaustive
                                   2        29               0.02
                                   3       137               0.08
                                   4       625                0.4
                                   5      2532                1.5
                                   6      9168                5.3
           Table 5. Number of combinatorial tests for Android example.



3.3   Cost and Practical Considerations

3.3.1 Invalid Combinations and Constraints

        The system described in Section 3.1 illustrates a common situation in all types of
testing: some combinations cannot be tested because they don’t exist for the systems under
test. In this case, if the operating system is either OS X or Linux, Internet Explorer is not
available as a browser. Note that we cannot simply delete tests with these untestable
combinations, because that would result in losing other combinations that are essential to
test but are not covered by other tests. For example, deleting tests 5 and 7 in Section 2.1.1
would mean that we would also lose the test for Linux with the IPv6 protocol.

        One way around this problem is to delete tests and Some combinations
supplement the test suite with manually constructed test
configurations to cover the deleted combinations, but covering
                                                                    never occur in
array tools offer a better solution. With ACTS we can specify practice.
constraints, which tell the tool not to include specified combinations in the generated test
configurations. ACTS supports a set of commonly used logic and arithmetic operators to
specify constraints. In this case, the following constraint can be used to ensure that invalid
combinations are not generated:
                (OS != “XP” => Browser = “Firefox”)

The covering array tool will then generate a set of test configurations that does not include
the invalid combinations, but does cover all those that are essential. The revised test
configuration array is shown in Figure 8 below. Parameter values that have changed from


16
