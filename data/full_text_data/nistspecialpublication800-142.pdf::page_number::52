Practical Combinatorial Testing
________________________________________________________________
8.3   Cost and Practical Considerations

     Assertions may be a cost-effective approach to test automation because they can be a
simple extension of coding. In general, use of assertions is correlated with reduced error
rates [41], but a very wide range of effectiveness results from variations in usage. In many
applications, assertions are used in a very basic way, such as ensuring that null pointers are
not passed to a function that will use them, or that parameters that may be used as divisors
are non-zero.

      More complex assertions can provide stronger assurance, but there are limits to their
effectiveness. For example, invariants (properties that are expected to hold throughout a
computation) cannot be assured without placing an assertion for every line of code. Since
assertions must be executed to show the presence or absence of a property at some point,
errors that prevent the assertion from being reached may not be detected. As an example,
consider the code in Figure 26. If a coding error in the first few lines of the function
prevents execution the code at of lines 15 and 17, the assertions will not be executed and it
may be assumed that the test was passed. In this case, an ERROR return for the particular
test case might trigger an investigation that would identify the faulty code, but this may not
happen with other applications.

8.4   Chapter Summary

       Assertions are one of the easiest to use and most effective approaches to dealing with
the oracle problem. Properties ranging from simple parameter checks to effectively
embedded proofs can be encoded in assertions, but special language support is needed for
the stronger forms of assurance. This support may be provided as language preprocessors,
as in the case of Anna [44] and others. Placement within code is particularly important to
assertion effectiveness [60, 61], but if sufficiently strong assertions are embedded, the code
becomes self-checking for important properties. With self-checking code, thousands of
tests can be run at low cost in most cases, greatly improving the chances that faults will be
detected.




46
