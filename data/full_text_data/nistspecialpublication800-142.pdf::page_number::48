Practical Combinatorial Testing
________________________________________________________________


8 ASSERTION-BASED TEST ORACLES

        Many programming languages include an assert feature that allows the programmer
to specify properties that are assumed true at a particular point in the program. For
example, a function that includes a division in which a particular parameter x will be used
as a divisor may require that this parameter may never be zero. This function may include
the C statement assert(x != 0); as the first statement executed. Note that the
assertion is not the same as an input validity check that issues an error message if input is
not acceptable. The assertion gives conditions that must hold for the function to operate
properly, in this case a non-zero divisor. It is the responsibility of the programmer to ensure
that a zero divisor is never passed to the function. The distinction between assertions and
input validation code is that assertions are intended to catch programming mistakes, while
input validation detects errors in user or file/database input.

         With a sufficient number of assertions derived from a
specification, the program can have a self-checking property With self-checking
[27, 60, 47]. The assertions can serve as a sort of embedded through assertions,
proof of important properties, such that if the assertions hold thousands of tests
for all executions of the program, then the properties can often be run at
encoded in the assertions are guaranteed to hold. Then, if the very low cost,
assertions form a chain of logic that implies a formal allowing high-
statement of program properties, the programâ€™s correctness
with respect to these properties can be proven. We can take strength interaction
advantage of this scheme in combinatorial testing by coverage.
demonstrating that the assertions hold for all t-way
combinations of inputs. While this is not the same as a correctness proof, it is an effective
way of integrating formal methods for correctness with program testing, and an extensive
body of research has developed this idea for practical use (for a survey, see [4]). Some
modern programming languages, such as Eiffel [52], include extensive support for
including assertions that encode program properties, and tools such as the Java Modeling
Language [42] have been designed to integrate assertions with testing. In many cases,
using assertions to self-check important properties makes it practical to run thousands of
tests in a fully automated fashion, so high-strength interactions of 4-way and above can be
done in reasonable time.

8.1   Basic Assertions for Testing

        To clarify this somewhat abstract discussion, we will analyze requirements for a
small function that handles withdrawal processing for an automated teller machine (ATM).
Graphical user interface code for the ATM will not be displayed, as this would vary
considerably for different systems. The decision not to include GUI code in this example
also illustrates a practical limitation of this type of testing: there are many potential
sources of error in a software project, and testing may not deal with all of them at the same
time. The GUI code may be analyzed separately, or a more complex verification with
assertions may specify properties of the GUI calls, but in the end some human involvement


42
