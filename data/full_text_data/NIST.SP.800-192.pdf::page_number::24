                                                                                             NIST SP 800-192                                                       VERIFICATION & TEST METHODS FOR
                                                                                                                                                                   ACCESS CONTROL POLICIES/MODELS

                                                                                             Thus, the AC rules define the system behaviors that function as the transition relation δ in M. Then
                                                                                             when the AC safety requirement is represented by temporal logic formula p, we can represent the
                                                                                             assertion that model M satisfies p by M |= Ab → AXp, where temporal logic quantifier A represents
                                                                                             “always”, and logic quantifier X represents “is true next state”. The purpose of safety verification
                                                                                             and liveness verification using model checking is to determine whether these assertions are true,
                                                                                             and to identify a state in which the assertions are not true as a counterexample for the assertions.
                                                                                             Since the behavior of the AC mechanism can be represented by FSM M, and the safety
                                                                                             requirements that M must satisfy can be represented by temporal logic formulas, we can define the
                                                                                             correctness more precisely as that the model can be led from every possible state that is reachable
                                                                                             from initial states to the defined final state while complying with the safety requirement.

                                                                                             Even though checked by the black box testing as described above, the model is not fault proof
This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-192




                                                                                             because the temporal logic in the model might not be thorough in covering all possible values of
                                                                                             all rules or all conditions in rules. For example, two states determined by opposite assignments of
                                                                                             the same Boolean variable are embedded in different sub-state modules, where a third state is
                                                                                             triggered only when the constraints of the two states are satisfied. As demonstrated in Figure 4,
                                                                                             the two rules will never agree due to the self-negation to the same constraint. In this case, the third
                                                                                             state will never be satisfied, but proven correct without counterexamples through the black box
                                                                                             checking.


                                                                                                   NEXT_STATE(p):= CASE {
                                                                                                     x :i
                                                                                                     ….
                                                                                                   }


                                                                                                   NEXT_STATE(q):= CASE {
                                                                                                     ! x :j
                                                                                                     ….
                                                                                                   }


                                                                                                   NEXT_STATE(access):= CASE {
                                                                                                     p = = i & q = = j :grant
                                                                                                     OTHERWISE: deny
                                                                                                     ……                                    AG means that condition (p = = i & q = = j) → access
                                                                                                   }                                       = grant is always, or globally, true in all the states of
                                                                                                                                           all the possible path in the model by CTL check
                                                                                               …….
                                                                                               AG (p = = i & q = = j) → access = grant


                                                                                                                        Figure 4 Example of unreachable state in the model


                                                                                             To detect this kind of semantic fault, white box testing based on code analysis should be applied
                                                                                             such that the resulting mutated versions are used to detects faults of the model. Testing for
                                                                                             mutations [MX07] makes sure all paths of a part of a model code are covered by setting the related
                                                                                             target variables to all possible values as input, and checking to see if there are different outcomes
                                                                                             from the changes. If there is none, then either the code that had been mutated was never executed
                                                                                             or the variable was unable to locate the faults. As shown in Figure 4, If we mutate the first case
                                                                                             module to change x to !x, the resulting access state will be grant without being affected. (That

                                                                                                                                               17
