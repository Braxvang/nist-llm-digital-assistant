Practical Combinatorial Testing
________________________________________________________________
     Testing all 4-way to 6-way combinations may therefore provide reasonably high
assurance. As with most issues in software, however, the situation is not that simple.
Efficient generation of test suites to cover all t-way combinations is a difficult
mathematical problem that has been studied for nearly a century. In addition, most
parameters are continuous variables which have possible values in a very large range (+/­
232 or more). These values must be discretized to a few distinct values. Most glaring of all
is the problem of determining the correct result that should be expected from the system
under test for each set of test inputs. Generating 1,000 test data inputs is of little help if we
cannot determine what the system under test (SUT) should produce as output for each of
the 1,000 tests.

     With the exception of combination covering test
                                                                          Advances in
generation, these challenges are common to all types of
software testing, and a variety of good techniques have been              algorithms have
developed for dealing with them. What has made combinatorial              made
testing practical today is the development of efficient algorithms        combinatorial
to generate tests covering t-way combinations, and effective              testing beyond
methods of integrating the tests produced into the testing                pairwise finally
process. A variety of approaches introduced in this publication
can be used to make combinatorial testing a practical and
                                                                          practical.
effective addition to the software tester’s toolbox.

    A note on terminology: we use the definitions below, following the Institute of
Electrical and Electronics Engineers [30]. The term “bug” may also be used where its
meaning is clear.
• error: a mistake made by a developer. This could be a coding error or a
   misunderstanding of requirements or specification.
• fault: a difference between an incorrect program and one that correctly implements a
   specification. An error may result in one or more faults.
• failure: a result that differs from the correct result as specified. A fault in code may
   result in zero or more failures, depending on inputs and execution path.

2.1   Two Forms of Combinatorial Testing

     There are basically two approaches to combinatorial testing – use combinations of
configuration parameter values, or combinations of input parameter values. In the first
case, we select combinations of values of configurable parameters. For example, a server
might be tested by setting up all 4-way combinations of configuration parameters such as
number of simultaneous connections allowed, memory, OS, database size, etc., with the
same test suite run against each configuration. The tests may have been constructed using
any methodology, not necessarily combinatorial coverage. The combinatorial aspect of this
approach is in achieving combinatorial coverage of configuration parameter values. (Note,
the term variable is often used interchangeably with parameter to refer to inputs to a
function.)

                                                                      Combinatorial
                                                                      testing can be
                                                                      applied to
6
                                                                      configurations,
                                                                      input data, or both.
