                                                          Practical Combinatorial Testing
 _______________________________________________________
          1.while (!valid(acct)) {/* get account number input */}
          2.if (amt > lim ) { return ERROR; }
          3.else {
          4. if (odflag ) {
          5.       if (amt > balance + odamt )
          6.       { return ERROR; }
          7. }
          8.else {
          9. if (amt > balance + oddefault )
          10.      {return ERROR; }
          11.      else {
          12.            if (amt > lim )
          13.            { return ERROR; }
          14.      }
          15. #include "wdl_init.c"
          16. balance -= amt ;
          17. #include "wdl_final.c"
          18. }
          19. }
          20. }
               Figure 26.      Withdrawal function code to be tested.


8.2   Stronger Assertion-based Testing

      While the method described in the previous section can be very effective in testing,
notice that it will be inadequate for many problems, because basic assertion functions such
as in C language library do not support important logic operators such as ∀ (for all) and ∃
(for some). Thus expressing simple properties such as S is sorted in ascending order =
∀i : 0 ≤ i < n − 1: S[i] ≤ S[i + 1] cannot be done without a good deal of additional coding.
While it would be possible to add code to handle these problems in assertions, a better
solution is to use an assertion language that is designed for the purpose and contains all the
necessary features.

      Tools such as Anna [44] for Ada, the Java Modeling language (JML) [42] and
iContract [28] for Java, and APP [57] or Nana [46] for C, can be used to introduce complex
assertions, effectively embedding a formal specification within the code. The embedded
assertions serve as an executable form of the specification, thus providing an oracle for the
testing phase. With embedded assertions, exercising the application with all t-way
combinations can provide reasonable assurance that the code works correctly across a very
wide range of inputs. This approach has been used successfully for testing smart cards,
with embedded JML assertions acting as an oracle for combinatorial tests [25]. Results
showed that 80% - 90% of errors could be found in this way.




                                                                                                 45
