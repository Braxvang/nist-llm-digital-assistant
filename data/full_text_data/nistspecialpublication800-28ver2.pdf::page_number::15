                                                               GUIDELINES ON ACTIVE CONTENT AND MOBILE CODE




                            Figure 2-1. Basic Components of a Generic Browser

To simplify browser development, software designs allow extensibility through a variety of techniques for
communicating with other functional components. The motivation is twofold: no one can reasonably
build in the means to render all forms of content, and to attempt to do so would limit innovation as well as
the usefulness of the browser. As long as the browser design employs or provides a well-defined
interface, other software producers can readily extend functionality with their components. In general,
the program components of a browser, both built-in and otherwise, can be divided into the classes
described below [Mor98].

 Components incorporated directly within the browser. Browsers contain a significant amount of
  built-in functionality and typically can inherently render a variety of content types, including text,
  HTML delimited text, scripting languages, Java applets, and common types of image files. The
  associated program components are functionally internal to the browser and able to interpret such
  content directly. To keep the browser safe from sources that have varying levels of trust, the program
  components must take precautions against arbitrary input received. Because these programs are
  contained within the browser, the browser manufacturer is able to impose security constraints on
  them. Built-in functionality is also a means for the manufacturer to distinguish its product from
  others in various ways such as offering proprietary extensions to standard script languages, close
  integration and interworking with other product offerings, and entirely new content handling
  capabilities.
    Built-in functionality should follow an explicit security model to ensure security. For example,
    enforcing the same origin policy, which prevents content loaded from one “origin’ (i.e., the context
    defined by host domain name, protocol, and port) from getting or setting properties of a document
    loaded from a different “origin,” is a fundamental policy employed by present-day browsers. The
    implementation of secure JavaScript in Mozilla illustrates the range of considerations involved in
    defining a security model [Anu98]. The implementation controls access to resources and external
    interfaces, prevents residual information from being retained and accessible among different contexts
    operating simultaneously or sequentially, and allows policy, which partitions the name space for
    access control purposes, to be specified independently of mechanism. Differences can and do exist in
    the security models used by different browsers.




                                                    2-5
