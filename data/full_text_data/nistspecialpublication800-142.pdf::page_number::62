Practical Combinatorial Testing
________________________________________________________________


10 FAULT LOCALIZATION

     Developing dependable software requires preventing as many bugs as possible and
detecting, then repairing, those that remain. Testing can identify flaws in software, but
after a failed test is discovered, it is necessary to determine what caused the failure. In
most cases this may be accomplished for combinatorial testing in the same way as other
test methodologies, using a debugger or in-circuit emulator. But one goal of combinatorial
testing is to identify the particular t-way combination that triggered a failure. The problem
of fault localization, identifying such combination(s), is an area of active research, but
some basic approaches can be identified. The discussion in this chapter assumes systems
are deterministic, such that a particular input always generates the same output.

     At first glance, fault localization may not appear to be a difficult problem, and in many
cases it will not be, but we want to automate the process as much as possible. To
understand the size of the problem, consider a module that has 20 input parameters. A set
of 3-way covering tests passes 100%, but several tests derived from a 4-way covering array
result in failure. (Therefore, at least four parameter values are involved in triggering the
failure. It is possible that a 5-way or higher combination caused the failure, since any set
of t-way tests also includes (t+1)-way and higher strength combinations as well.) A test
with 20 input parameters has C(20, 4) = 4,845 4-way combinations, yet presumably only
one (or just a few) of these triggered the failure. To determine the combination at fault, a
variety of strategies can be used.

10.1 Set-theoretic Analysis

     The analysis presented here applies to a deterministic system, in which a particular set
of input values always results in the same processing and outputs. Let P = {combinations
in passing tests} and F = {combinations in failing tests} and C = {fault-triggering
combinations}. Then F \ P , combinations in failing tests that are not in any passing tests,
must contain the fault-triggering combinations C because if any of those in C were in P,
then the test would have failed. So in most cases, C ⊆ F \ P , as shown in Figure 30.



                                         C⊆F\P
                                                                      C⊆F\P
                                          P          F




       Figure 30.     Combinations in failing tests but not in passing tests.




56
