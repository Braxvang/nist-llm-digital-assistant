Practical Combinatorial Testing
________________________________________________________________
true for the given model, the model checker reports this fact. What makes a model checker
particularly valuable for many applications, though, is that if the statement is false, the
model checker not only reports this, but also provides a “counterexample” showing how
the claim in the SPEC statement can be shown false. The counterexample will include
input data values and a trace of system states that lead to a result contrary to the SPEC
claim (Figure 28). In the process described in this section, the input data values will be the
covering array generated by ACTS.

         For advanced uses in test generation, this counterexample generation capability is
very useful for proving properties such as liveness (absence of deadlock) that are difficult
to ensure through testing. In this tutorial, however, we will simply use the model checker
to determine whether a particular input data set makes a SPEC claim true or false. That is,
we will enter claims that particular results can be reached for a given set of input data
values, and the model checker will tell us if the claim is true or false. This gives us the
ability to match every set of input test data with the result that the system should produce
for that input data.
         The model checker thus automates the work that normally must be done by a
human tester – determining what the correct output should be for each set of input data. In
some cases, we may have a “reference implementation”, that is, an implementation of the
functions that we are testing that is assumed to be correct. This happens, for example, in
conformance testing for protocols, where many vendors implement their own software for
the protocol and submit it to a test lab for comparison with an existing implementation of
the protocol. In this case the reference implementation could be used for determining the
expected output, instead of the model checker. Of course before this can happen the
reference implementation itself must be thoroughly tested before it can be used as the gold
standard for testing other products, so the method we describe here may be needed to
produce tests for the original reference implementation.

        Checking the properties in the SPEC statements shows that they match the access
control rules as implemented in the FSM, as expected. In other words, the claims we made
about the state machine in the SPEC clauses can be proven. This step is used to check that
the SPEC claims are valid for the model defined previously. If NuSMV is unable to prove
one of the SPECs, then either the spec or the model is incorrect. This problem must be
resolved before continuing with the test generation process. Once the model is correct and
SPEC claims have been shown valid for the model, counterexamples can be produced that
will be turned into test cases, by which we mean a set of test inputs with the expected result
for these inputs. In other words, ACTS is used to generate tests, then the model checker
determines expected results for each test.


  -- specification AG((u_l >= f_l & act = rd) -> AX access = GRANT)
      is true
 -- specification AG((f_l >= u_l & act = wr) -> AX access = GRANT)
      is true
 -- specification AG(!((u_l >= f_l & act = rd)|(f_l >= u_l & act = wr))
                                      -> AX access = DENY) is true
                              Figure 28.      NuSMV output



50
