                                  NIST Special Publication 800-38F


   2. Calculate the intermediate values. For t = 1, …, s, update the variables as follows:
         a) At = MSB64(CIPHK(At-1 || R2t-1)) ⊕ [t]64;
         b) For i = 2, …, n-1: Rit = Ri+1t-1;
         c) Rnt = LSB64(CIPHK (At-1 || R2t-1)).
   3. Output the results:
         a) Let C1 = As.
         b) For i = 2, …, n: Ci = Ris.
         c) Return C1 || C2 || … || Cn.

Figure 1 illustrates the wrapping function applied to four semiblocks, i.e., W(S1 || S2 || S3 || S4) =
C1 || C2 || C3 || C4 . Each “wire” carries a semiblock, and each of the eighteen numbered
rectangles represents an invocation of the underlying block cipher with the KEK. On the left side
of these rectangles, the input block’s most significant 64 bits enter the top wire, while on the
right side of these rectangles, the output block’s most significant 64 bits exit the bottom wire;
this convention reduces the number of wire crossings.




                           Figure 1: Illustration of the wrapping function, W

Figure 2 illustrates the assignment of intermediate values within Step 2 of Algorithm 1. The
dashed lines indicate the assignments of new values to the n semiblock variables. The variable
that indexes the iterations, t, increases from 1 to 6(n-1).

                                       At-1   R2t-1        R3t-1    …      Rn t-1


                   [t]64                 CIPHK


                                   MSB64       LSB64


                 Figure 2: Illustration of an iteration within Step 2 of Algorithm 1




                                                  12
