NIST SP 800-207A                                          ZTA Model for Access Control in Cloud-Native
September 2023                                              Applications in Multi-Location Environments


4.6.3. Advantages of Identity-Tier Policies
Policies based on service and application identities do not use any infrastructure-related variables
(e.g., IP addresses, subnets), so they are environment-agnostic and provide the freedom for the
services and applications to be migrated to different environments and still maintain the same
policies. In other words, there can be a consistent set of policies across cloud providers and on-
premises because the policy follows the application rather than the network.
   •   Identity-tier policies enable the automated testing of policies. Policies that are
       independent of infrastructure can be tested by merely exercising the application and
       observing the outcomes (e.g., trace the sequence of service calls and requests or
       responses instead of configuring the infrastructure correctly for test runs).
   •   Identity-tier policies enable “policy as code” (PaC). With the availability of tools for the
       declarative specification of policies through PaC, identity-tier policies can be defined and
       implemented by incorporating the code into automated workflows, such as continuous
       integration/continuous delivery (CI/CD) pipelines.
   •   Identity-tier policies enable fine-grained access control by providing visibility into
       application call sequences/interdependencies and data flows through request-level
       tracking, which enables the enforcement of security policies for application traffic that is
       both north-south and east-west, irrespective of the environment (e.g., corporate data
       center or cloud infrastructure).
Additional advantages include:
   •   Write once, enforce everywhere — This means that policy can span environments and
       topologies (i.e., write a policy once and enforce it everywhere) rather than bespoke
       policies per environment.
   •   Human-readable primitives — The written policies use human-understandable primitives
       (e.g., “service A can call service B”) rather than network-oriented primitives (e.g.,
       “10.1.2.3/30 is allowed to call 10.100.2.3/30 on port 8080”). This context is critical since
       the lack of context for rules is a key reason for the lack of agility around traditional
       network policy.
   •   Contextual intent is codified in a single policy — There is a single policy rather than a set
       of policies that need to be pieced together to understand their intent. A human can read a
       policy like “the front-end service is allowed to call ‘GET /foo’ (a method) on the back-
       end service” and understand the access that the policy intends to convey even if, for
       example, the front end is deployed in the cloud and the back end is deployed on-
       premises. It is significantly harder to read and understand a set of network peering and
       firewall rules that allow communication across the DMZ for a set of subnets. In turn, this
       means it is harder to write the wrong policy and easier for a human to understand when a
       policy is incorrect.
Identity-tier policies enable only valid network traffic between the various component services of
the application due to the mutual authentication and authorization of the service identities, thus
enabling the goals of zero trust network access (ZTNA) to be met.

                                                 19
