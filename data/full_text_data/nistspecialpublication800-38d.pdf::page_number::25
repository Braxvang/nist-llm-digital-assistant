                                NIST Special Publication 800-38D


       additional authenticated data A;
       authentication tag T.


       Output:
       plaintext P or indication of inauthenticity FAIL.

       Steps:
       1. If the bit lengths of IV, A or C are not supported, or if len(T) ≠ t, then return FAIL.
       2. Let H = CIPHK(0128).
       3. Define a block, J0, as follows:
           If len(IV)=96, then J0 = IV || 031 ||1.
           If len(IV) ≠ 96, then let s = 128 ⎡len(IV)/128⎤-len(IV), and
                J0=GHASHH(IV||0s+64||[len(IV)]64).
       4. Let P=GCTRK(inc32(J0),C).
       5. Let u = 128 ⋅ ⎡len(C ) 128⎤ − len(C ) and let v = 128 ⋅ ⎡len( A) 128⎤ − len( A) .
       6. Define a block, S, as follows:
                        S = GHASHH(A || 0v || C || 0u || [len(A)]64 || [len(C)]64)
       7. Let T ′ = MSBt (GCTR K ( J 0 , S )) .
       8. If T = T ′ , then return P; else return FAIL.

In Step 1, the implementation’s support for the lengths of the IV, the ciphertext, the AAD, and
the authentication tag is verified. In Step 2, the hash subkey for the GHASH function is
generated by applying the block cipher to the “zero” block. In Step 3, the pre-counter block (J0)
is formed as for the authenticated encryption function (Step 2 of Section 7.1). In Step 4, the 32-
bit incrementing function is applied to the pre-counter block to produce the initial counter block
for an invocation of the GCTR function on the ciphertext. The output of this invocation of the
GCTR function is the plaintext that corresponds to the ciphertext for the given IV.

In Steps 5 and 6, the AAD and the ciphertext are each appended with the minimum number of
‘0’ bits, possibly none, so that the bit lengths of the resulting strings are multiples of the block
size. The concatenation of these strings is appended with 64-bit representations of the lengths of
the AAD and the ciphertext, and the GHASH function is applied to the result to produce a single
output block. In Step 7, this output block is encrypted using the GCTR function with the pre-
counter block that was generated in Step 3, and the result is truncated to the specified tag length
to form the authentication tag. In Step 8, the result of Step 7 is compared with the authentication
tag that was received as an input: if they are identical, then the plaintext is returned; otherwise,
FAIL is returned.

Equivalent sets of steps that produce the correct output are permitted.           In particular, the
verification of the tag may precede the computation of the plaintext.

The authenticated decryption function is illustrated in Figure 4 below. The determination of J0
from IV (Step 3) is not depicted.




                                                17
