                                                          Practical Combinatorial Testing
 _______________________________________________________
 u_l = 2 & f_l = 2 & act = rd -> access = GRANT
 u_l = 0 & f_l = 2 & act = rd -> access = DENY
 u_l = 1 & f_l = 0 & act = wr -> access = DENY
 u_l = 2 & f_l = 1 & act = wr -> access = DENY

These test definitions can now be post-processed using simple scripts written in PERL,
Python, or similar tool to produce a test harness that will execute the SUT with each input
and check the results. While tests for this trivial example could easily have been
constructed manually, the procedures introduced in this tutorial can, and have, been used to
produce tens of thousands of complete test cases in a few minutes, once the SMV model
has been defined for the SUT.

9.3   Cost and Practical Considerations

     Model based test generation trades up-front analysis and specification time against the
cost of greater human interaction for analyzing test results. The model or formal
specification may be costly to produce, but once it is available, large numbers of tests can
be generated, executed, and analyzed without human intervention. This can be an
enormous cost savings, since testing usually requires 50% or more of the software
development budget. For example, suppose a $100,000 development project expects to
spend $50,000 on testing, because of the staff time required to code and run tests, and
analyze results. If a formal model can be created for $20,000, complete tests generated and
analyzed automatically, with another $10,000 for a smaller number of human-involved
tests and analysis, then the project will save 20%. One tradeoff for this savings is the
requirement for staff with skills in formal methods, but in some cases this approach may be
practical and highly cost-effective.


9.4   Chapter Summary

1. The oracle problem must be solved for any test methodology, and it is particularly
   important for thorough testing that produces a large number of test cases. One
   approach to determining expected results for each test input is to use a model of the
   system that can be simulated or analyzed to compute output for each input.

2. Model checkers can be used to solve the oracle problem because whenever a specified
   property for a model does not hold, the model checker generates a counter-example.
   The counter-example can be post-processed into a complete working test harness that
   executes all tests from the covering array and checks results.

3. Several approaches are possible for integrating combinatorial testing with model
   checkers, but some present practical problems. The method reported in this chapter can
   be used to generate full combinatorial test suites, with expected results for each test, in
   a cost effective way.




                                                                                                 55
