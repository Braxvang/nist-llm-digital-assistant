                                                                                             NIST SP 800-192                                                   VERIFICATION & TEST METHODS FOR
                                                                                                                                                               ACCESS CONTROL POLICIES/MODELS

                                                                                             This code can be mapped to the following expression:

                                                                                                   (a(cd̅ +e) → grant)
                                                                                                   (a̅bc̅ → grant)
                                                                                                   ((∼(a(cd̅ +e)))(∼(a̅bc̅)) → deny)

                                                                                                   The boolean literals may represent conditions, such as age>18, or boolean attributes such
                                                                                             as employee, but the structure will be as shown in the example. That is, a series of expressions
                                                                                             specifying subsets of attribute conditions that must be true for access to be granted, followed by
                                                                                             a default deny-access rule when none of the attribute expressions have been instantiated to true.

                                                                                                   Testing an implementation requires showing that the policy specified, P, is correctly
This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-192




                                                                                             implemented. The implemented policy P’ must be shown to produce the same response as P for
                                                                                             any combination of attributes used as input. That is, for input attributes x1,…,xn, P’(x1,…,xn) =
                                                                                             P(x1,…,xn).

                                                                                                   Confirming that access will be granted for users with the right attributes is easy: we can
                                                                                             simply read off the attribute conditions for each grant expression and verify that the access
                                                                                             control system returns an authorization in each case. The number of such tests is linear in the
                                                                                             number of grant conditions. However, it is much more difficult to ensure that no invalid
                                                                                             combination of attributes will result in authorization. With n boolean attributes or variables there
                                                                                             are 2n possible combinations of attributes. For example, it would not be unusual to have 50
                                                                                             conditions or Boolean attributes, resulting in 250 ≈ 1015 combinations, but it must be shown that
                                                                                             no combination will improperly allow access.

                                                                                                   To make testing tractable, we will use covering arrays of attributes in policies that have
                                                                                             been converted to k-DNF form. k-DNF refers to disjunctive normal form where no term contains
                                                                                             more than k literals. Recall that a term is a conjunction of one or more literals within the
                                                                                             disjunction. For example, abc + de contains two terms, one with three literals and one with two,
                                                                                             so the expression is in 3-DNF form. A 3-way covering will contain all 3-way combinations of
                                                                                             variable values (and therefore also all 1-way and 2-way combinations). Where an expression is
                                                                                             in k-DNF, any term containing k literals that is resolved to true will clearly result in the full
                                                                                             expression being evaluated to true. For example, a rule in 2-DNF form could be: “if employee
                                                                                             && US_citizen || auditor then grant”. This rule contains one term of two attributes and one
                                                                                             term of one attribute, so it is 2-DNF. Because a covering array of strength k contains every
                                                                                             possible setting of all k-tuples and i-tuples for i < k, it contains every combination of values of
                                                                                             any k literals.

                                                                                                  Covering array generation tools, such as ACTS, make it possible to include constraints that
                                                                                             prevent the inclusion of variable combinations that meet criteria specified in a first order logic
                                                                                             style syntax. For example, if we are testing applications that run on various combinations of
                                                                                             operating systems and browsers, we may include a constraint such as ‘OS = “Linux” => browser
                                                                                             != “IE”’. Constraints are typically used in situations such as this, where certain combinations do
                                                                                             not occur in practice, and therefore should not be included in tests.




                                                                                                                                             38
