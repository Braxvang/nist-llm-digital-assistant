                                                                                             NIST SP 800-192                                                    VERIFICATION & TEST METHODS FOR
                                                                                                                                                                ACCESS CONTROL POLICIES/MODELS

                                                                                             u_l = 2 & f_l = 2 & act = rd -> access = GRANT
                                                                                             u_l = 0 & f_l = 2 & act = rd -> access = DENY
                                                                                             u_l = 1 & f_l = 0 & act = wr -> access = DENY
                                                                                             u_l = 2 & f_l = 1 & act = wr -> access = DENY

                                                                                             These test definitions can now be post-processed using simple scripts to produce a test cases for
                                                                                             the test oracle.

                                                                                             5.6   Pseudo-exhaustive Testing

                                                                                                  This section describes a method of testing for access control systems (or other systems with
                                                                                             formally specified rules) that is pseudo-exhaustive, which we define as exhaustive testing of all
                                                                                             combinations of attribute values on which an access control decision is dependent [KHFKL16].
This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-192




                                                                                             An advantage of this method is that it can be used to produce a complete test set, in the sense that
                                                                                             all negative cases as well as all positive cases are verified. This approach is analogous to pseudo-
                                                                                             exhaustive methods for testing combinational circuits, where the verification problem is reduced
                                                                                             by exhaustively testing only the subset of inputs on which an output is dependent, or by partitioning
                                                                                             the circuit and exhaustively testing each segment. We can use the basic principle of testing only
                                                                                             subsets of attributes on which a decision is dependent, although the partitioning is done in a
                                                                                             different manner than for combinational circuits. The structure of the access control problem
                                                                                             makes it possible to apply the same principle by rendering the conditions for each grant in
                                                                                             disjunctive normal form, then considering each term separately.

                                                                                                  For example, a rule with attributes employment_status and time_of_day might be, “If subject
                                                                                             is an employee and the hour is between 9 am and 5 pm, then allow entry.” The problem with this
                                                                                             approach is that n boolean attributes or variables result in potentially 2n rules. Many such rules
                                                                                             may be included in written policy documents, and rules may include a variety of attributes. For
                                                                                             any combination of attribute values, the system must implement rules that accurately reflect the
                                                                                             written policy. The structure of such rules is typically as follows, where Ri are boolean conditions
                                                                                             evaluating the values of one or more attributes:
                                                                                                  R1 → grant
                                                                                                  R2 → grant
                                                                                                  …
                                                                                                  Rm → grant
                                                                                                  else → deny

                                                                                             which is equivalent to:
                                                                                                 R1 → grant
                                                                                                 R2 → grant
                                                                                                 …
                                                                                                 Rm → grant
                                                                                                 (~R1) (~R2)… (~Rm) → deny

                                                                                             Example: Suppose we have an access rule as shown below:
                                                                                                   if (a && (c && !d ||e))      grant();
                                                                                                   else if (!a && b && !c)      grant();
                                                                                                   else deny();



                                                                                                                                              37
