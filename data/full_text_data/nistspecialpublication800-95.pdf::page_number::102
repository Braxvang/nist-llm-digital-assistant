                                                                              GUIDE TO SECURE WEB SERVICES



nesting elements three or four levels, perhaps more. An attacker can easily create a document that
attempts to stress and break an XML parser by creating a document that is 10,000 or 100,000 elements
deep.

A.5.3     Oversized Payloads Sent to XML Parsers

XML is verbose by design in its markup of existing data and information, so file size must always be
considered. While an enterprise’s programmers and analysts will work to limit the size of a document,
there are a number of reasons to have XML documents that are hundreds of megabytes or gigabytes in
size. Sometimes this is a function of converting a batch file transfer process into a realtime process. It
may also occur in the multimedia (e.g., digital video) world where gigabyte files are the norm. Or, it
could be an attacker again exercising the parser to execute a DoS attack. Parsers based on the document
object model, which represent the entire XML document in memory, are especially susceptible to this
attack, given their need to model the entire document in memory prior to parsing. Coercive parsing,
discussed above, is an example of sending an oversized payload.

A.5.4     Schema Poisoning

In addition to attacking confidentiality (see Appendix A.4.2), schema poisoning can be used to perform a
DoS attack. Attacks against the grammar of an XML file can be easily achieved if the XML schema is
compromised.

XML documents need to conform to the protocols and specifications governing their use. It is common
for attackers to attempt to manipulate documents contrary to those rules to conduct a DoS attack or
compromise external sources. For example, a perfectly formed XML document may be inappropriate and
undesirable to a specific Web service if it contains policy violations such as excessive size, inclusion of
inappropriate or unexpected values, or data dependencies within the content. WSDL files and schemas
may be enumerated or spoofed with similar objectives.

A.5.5     Memory Leak Exploitation

Memory leaks occur when a program dynamically allocates memory space for an object, array, or
variable of some other type, but fails to free up the space before the program finishes executing.
Repeated over time, memory leaks can cause the program to allocate all available memory (physical
memory and paging file space), with the result that all software processes on the allocating program’s
host suspend operation until the allocating program releases the memory. Memory leaks can be exploited
by attackers by inserting malicious code that is written to hog memory resources and cause DoS.

Memory leaks are most common in programs that allocate arrays and variable data types. It is important
to write programs that always deallocate local arrays before terminating execution of subroutines. Global
arrays should be deallocated whenever they are not being used. Some widgets, such as Data Access
Object (DAO) components and computing grid components, may include memory leaks if their properties
are not handled correctly. Memory leaks provide an easy entry point for buffer overflow attacks.

A.6 Command Injection

In a command injection, executable logic is inserted in non-executable text strings submitted to a
provider/provider Web service. The main types of command injection are SQL injection targeting Web
service-enabled database applications, and XML injection targeting Web services. Common command
injection attacks are described below. Command injections are usually the result of a design,
implementation, or configuration defect. Most commonly, command injections result in Web services



                                                    A-9
