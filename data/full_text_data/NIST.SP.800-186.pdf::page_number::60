NIST SP 800-186                                                     Discrete Logarithm-based Cryptography:
February 2023                                                             Elliptic Curve Domain Parameters

                   Set e = 2e.
           b) Update values:
                             𝑚𝑚−𝑖𝑖−1
                   𝑏𝑏 = 𝑐𝑐 2           (mod 𝑝𝑝)
                   𝑥𝑥 = 𝑥𝑥𝑥𝑥(mod 𝑝𝑝)
                   𝑡𝑡 = 𝑡𝑡𝑏𝑏 2 (mod 𝑝𝑝)
                   𝑐𝑐 = 𝑏𝑏 2 (mod 𝑝𝑝)
                   𝑚𝑚 = 𝑖𝑖
The solution is x, and the second solution is p – x. If the least i found is m, then no solution
exists.
Square roots in a non-binary field GF(q) are relatively efficient to compute if q has the special
form q ≡ 3 mod 4 or q ≡ 5 mod 8. All but one of the elliptic curves recommended in this
Recommendation are defined over such fields. The following routines describe simplified cases
to compute square roots for p ≡ 3 mod 4 or p ≡ 5 mod 8.
   To find a square root of (u/v) if p ≡ 3 mod 4 (as in E448), first compute the candidate root x =
   (u/v) (p+1)/4 = u3 v (u5v3) (p-3)/4 mod p. If v x2 = u, the square root is x. Otherwise, no square root
   exists.
   To find a square root of (u/v) if p ≡ 5 mod 8 (as in Edwards25519), first compute the
   candidate root x = (u/v) (p+3)/8 = u v3 (u v7) (p-5)/8 mod p. To find the root, check three cases:
       1. If v x2 = u mod p, the square root is x.
       2. If v x2 = –u mod p, the square root is x × 2((p-1)/4).
       3. Otherwise, no square root exists for modulo p.
   If x = 0 and x0 = 1, point decoding fails. If x mod 2 = x0, then the x-coordinate is x.
   Otherwise, the x-coordinate is p – x.

E.4.   Computing Inverses in GF(q)
If x is an element of GF(q) and x ≠ 0, its (multiplicative) inverse is the element xq−2.
If one is concerned about side-channel leakage, one should compute the inverse using a
constant-time algorithm. For example, one could indirectly compute u−1 by first computing the
inverse of the blinded element λu, where λ is a random non-zero element of GF(q), and
subsequently computing λ(λu)−1 = u−1. This yields an inversion routine where the inversion
operation itself does not require side-channel protection and which may have relatively low
computational complexity. Note that there may be other more efficient constant-time inversion
algorithms.




                                                   49
