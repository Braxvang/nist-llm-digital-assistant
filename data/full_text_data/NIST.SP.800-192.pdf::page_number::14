                                                                                             NIST SP 800-192                                                   VERIFICATION & TEST METHODS FOR
                                                                                                                                                               ACCESS CONTROL POLICIES/MODELS

                                                                                             c) Historical Policy Class

                                                                                             Policies in the Historical Policy Class regulate access permissions by historical access states or
                                                                                             recorded and predefined series of events. Representative AC policies for this type of AC policies
                                                                                             include Chinese Wall and Workflow AC policies. This policy class can be best described by
                                                                                             synchronous or direct specification expressions of an FSM model. For example, the synchronous
                                                                                             FSM specification in Example 3 specifies a Chinese Wall AC policy where there are two Conflict
                                                                                             of Interest groups COI1, COI2 of objects:

                                                                                             { VARIABLES
                                                                                                   access {grant, deny};
                                                                                                   act {rd, wrt};
This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-192




                                                                                                   object {none, COI1, COI2};
                                                                                                   state {1, 2, 3};
                                                                                                 INITIAL_STATE(state) := 1;
                                                                                                 INITIAL_STATE(object) := none;
                                                                                                 NEXT_STATE(state) := CASE {
                                                                                                   state == 1 & act == rd & object == COI1: 2;
                                                                                                   state == 1 & act == rd & object == COI2: 3;
                                                                                                   state == 2 & act == rd & object == COI1: 2;
                                                                                                   state == 2 & act == rd & object == COI2: 2;
                                                                                                   state == 3 & act == rd & object == COI1: 3;
                                                                                                   state == 3 & act == rd & object == COI2: 3;
                                                                                                   OTHERWISE: 1; };
                                                                                                NEXT_STATE(access) := CASE {
                                                                                                   state == 2 & act == rd & object == COI1: grant;
                                                                                                   state == 3 & act == rd & object == COI2: grant;
                                                                                                  OTHERWISE: deny; };
                                                                                                  NEXT_STATE (act) := act;
                                                                                                  NEXT_STATE (object) := object; }

                                                                                                                               Example 3 â€“ historical AC model

                                                                                             Note that in practice, the same AC policies may be expressed by multiple different AC models or
                                                                                             expressed by a single model in addition to extra constraint rules outside of the model. Verifying
                                                                                             the conformance of AC policies and models is a non-trivial and critical task. One important aspect
                                                                                             of such verification is to formally check for inconsistency and incompleteness of the model and to
                                                                                             verify safety requirements, because an AC model does not necessarily explicitly express the policy,
                                                                                             which can also be implicitly embedded by mixing with direct access constraints or other AC
                                                                                             models.




                                                                                                                                                 7
